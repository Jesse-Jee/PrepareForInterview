# 数据库隔离级别
## 1 事务
事务是一些操作的集合，用专业术语讲，它是一个程序的执行单元。事务本身并不包含这4个特性，我们需要通过一些手段，尽可能的让执行单元满足这4个特性。
那么我们就可以称它为事务，或者说是一个正确的事务，完美的事务。

## 2 四大特性ACID
- 原子性：满足原子操作单元。要么全部成功，要么全部失败。
- 一致性：事务的开始和完成，数据都必须保持一致。
- 持久性：数据的修改是永久的。
- 隔离性：事务之间是相互独立的，中间状态对外不可见。

## 3 隔离级别
### 3.1 并发情况下事务引发的问题
一般情况下，多个操作单元并发执行，会出现这么几个问题  
- 脏读：A事务还没提交，B事务就读到了A事务的结果。（破坏了隔离性）
- 不可重复读：A事务在本次事务中，对自己未操作的数据，进行了多次读取，结果出现了不一致或不存在的情况。（破坏了一致性，update和delete）
- 幻读：A事务在本次事务中，对自己未操作的数据，进行了多次读取，第一次读时，数据不存在，第二次读时，数据出现了。（破坏了一致性，insert情况）

### 3.2 引发问题的解决
为了权衡隔离和并发的矛盾，ISO定义了四个事务的隔离级别，每个级别的隔离程度不同，出现的副作用也不同。
- 读未提交（read-uncommitted）: 最低级别，只能保证持久性 
- 读提交 （read-committed）: 语句级别
- 可重复读（repeatable-read）: 事务级别
- 串行化（serializable）: 最高级别，事务与事务完全串行化执行，毫无并发可言，性能极低。  

| 级别 | 脏读 | 不可重复读 | 幻读 |  
| :---: | :---: | :---: | :---: |  
|Read uncommitted|	√|	√|	√|
|Read committed|	×|	√|	√|
|Repeatable read|	×|	×|	√|
|Serializable|	×|	×|	×|

### 3.3 实现（InnoDB）
- 锁机制：当一个事务在执行的时候，阻止其他事务对该事务进行操作。各个隔离级别主要体现在读取数据时加的锁和释放时机。
  - read-uncommitted: 事务读取时不加锁
  - read-committed: 事务读取时加行级锁（读到才加锁），一旦读完，立刻释放（并不是事务结束）
  - repeatable-read: 事务读取时加行级共享锁，直到事务结束才会释放。
  - serializable: 事务读取时加表级共享锁，直到事务结束才释放。
- MVCC机制：生成一个数据快照，并用这个快照来提供一致性的读取，也称为多版本数据控制。
  - 实际上就是CAS版本控制和读写分离的思想
  - 主要作用于 读提交和可重复读级别


#### 3.3.1 LBCC 基于锁的控制
- 乐观锁、互斥锁
- 意向锁
- 行锁
- 间隙锁
- 行锁+间隙锁
- 插入意向锁
- 自增锁
- 空间索引预测锁


#####  3.3.1.1 表锁与行锁区别
表锁相当于包酒店
行锁相当于包房间

- 锁定粒度： 表锁>行锁   
- 加锁效率： 表锁>行锁   
- 冲突概率： 表锁>行锁   
- 并发性能： 表锁<行锁  

##### 3.3.1.2 shared locks(行锁) 共享锁，读锁
对某个资源加共享锁，自身可以读该资源，其他人也可以读资源，但无法修改。要想修改需要等共享锁释放后。

加锁： select * from table **lock in share mode**;  
释放锁： commit\rollback;

##### 3.3.1.3 Exclusive locks（行锁） 排它锁
对某个资源加排它锁，自身可以进行增删改查，其他人无法进行任何操作。  
排它锁不能和其他锁共存。  

在任何数据上，只要你加了排它锁，别人都玩不了的。  

加锁： select * from table where id = 1 **for update**;  

释放锁：commit,rollback;
 

##### 3.3.1.4 Intention locks 意向锁
均为表锁，无法手动创建
- 意向共享锁
- 意向排它锁

###### 为什么要加入意向锁？
意向锁不是用来锁定数据的，而是告诉事务，当前已经有个人在占坑了。  
这样就不用一行一行扫描来确定有没有共享锁，有没有排它锁。  
而是直接看表的状态上有没有意向锁来判断我能不能创建一个表锁。  
说白了就是为了提高加表锁的效率

##### 3.3.1.5 自增锁
既满足加锁，又满足高并发的行为。  
级别有 0，1，2  
当innodb_autoinc_lock_mode=2时，效率是最高的。
默认用的是1
0 是表锁，满足123456递增的特性

#### 3.3.2 锁算法
##### 3.3.2.1 Record locks 记录锁
等值查询，精准命中就会使用记录锁
通过主键去查询某条记录，用的就是记录锁。

##### 3.3.2.2 Gap locks 间隙锁
开区间如（-∞，1）（1，5）（5，9）（9，11）（11，∞）  
间隙锁只存在于可重复读级别
间隙锁不排它，即在间隙锁的时候，我在某个记录上加排它锁，是成功的，即使这个记录不存在。


##### 3.3.2.3 Next-key locks 临键锁
就是间隙锁+记录锁
右闭区间，如（-∞，1]（1，5]（5，9]（9，11]（11，∞）

当查询区间正好在如 大于5小于9的时候，开启临键锁。




#### 3.3.3 MVCC
MVCC主要是为了提高并发的读写性能，不用加锁就能让多个事务并发。
相当于在开启某个事务的时候，对当前数据库里的数据拍个快照，一致性视图read-view。


innodb在begin事务时，会分配一个事务ID给事务，叫transaction_id，严格递增。  
如 1 age = 12    
事务A修改age=18，它会把事务的transaction_id赋值给这个版本事务ID，记到row_trx_id中。即 row_trx_id=transaction_id  
拍照拍的是什么？拍的是版本号，或者说是事务ID。


**Innodb+MVCC 一定程度上解决了幻读问题。通过多版本号。**  

##### 当前读
当前事务修改的数据，事务自己认不认？  
认。
这就破坏了快照读，所以叫当前读。  
但是当前读可能会一定程度导致幻读。    

# 索引
## 什么是索引？
索引就是帮助MYSQL高效获取数据的**排好序**的**数据结构**  

## 索引的数据结构
- 二叉树
- 红黑树
- hash表 ：对范围查找不友好。
- B树/B+树

### 二叉树
最坏情况可能造成单链表。  

### 红黑树
大数据量时，树的深度会太高，查找次数也会很多。

### B树
- 叶节点具有相同的深度，叶节点的指针为空
- 所有索引元素不重复
- 节点的数据索引从左到右递增排列  
![Image_text](https://raw.githubusercontent.com/jizengguang/PrepareForInterview/master/Picture/btree.png)


### B+树
- 非叶子节点不存储data，只存储索引，可以放更多索引。
- 叶子节点包含所有索引字段
- 叶子节点用指针连接，提高区间访问性能。 妙啊 

![Image_text](https://raw.githubusercontent.com/jizengguang/PrepareForInterview/master/Picture/b%2Btree.png)



高度为3的一个B+树，可以存2000多万条数据。
每层非叶子节点MySQL设置为可存16kb。每条数据为节点指针8字节+6字节=14字节，因此B+树每层可以有1170个分叉。
每层存1170索引元素，叶子节点中是索引元素和索引元素磁盘地址指针，假设一个占1kb，那么一个叶子节点就可以存16个。
因此，1170*1170*16=2000多万


## Innodb数据是怎么存储的？
数据都是存储在磁盘上。
- xxx.frm 存储着表结构等
- xxx.ibd 索引+数据，按照B+组织的索引结构文件  

与B+树不同的是，索引结构文件的存储，叶子节点存储的不再是索引地址，而是数据。

## mylsam数据是怎么存储的？
- xxx.frm 存储表结构等
- xxx.MYI 存储索引
- xxx.MYD 存储数据

## 聚集索引（主键索引）
Innodb的主键索引，就是聚集索引。  
什么是聚集索引，就是索引和数据聚集在一个文件里。  
查找数据只需要从ibd文件中查找。  
所以聚集索引查找效率肯定比非聚集索引高。因为非聚集索引要查两个文件啊。  
### 主键索引和非主键索引查询有什么区别？
主键索引，叶子节点存储的是整行数据。  
非主键索引叶子节点存储的是主键的值，非主键索引也称为二级索引。  
当使用主键查询时，根据主键搜索B+树即可。  
而基于非主键索引查询时，先需要根据非索引主键查询到索引的值，再到主键索引树种搜索一次，这个过程叫回表。   
 
**也就是说非主键索引查询需要多扫描一棵索引树。**


## 非聚集索引
索引和数据分开存储，就是非聚集索引
查找数据需要从MYI文件找了再去MYD中找。


## 为什么Innodb表必须有主键，并且推荐使用整型的自增主键。
因为innodb标文件就是按照B+树组织的。没有主键数据是没办法组织的。  
如果建表的时候你没建，它会自动选一列可以唯一标识的建主键，如果找不到这样的列，就会在表里面默认加一列。


## 覆盖索引
想查的值，在以给出的索引树上，可以直接提供查询结果，不需要回表。也就是说，查询条件的索引已经覆盖了查询请求，称之为覆盖索引。  
覆盖索引可以减少树的搜索次数，显著提高查询性能。  



## 联合索引
### 底层存储结构什么样？
假设，name,age,position组成联合索引。排好序。  
则它们的排列规则为：  
先检查第一个索引，从左到右依次比较，小的在前，大的在后。  
如果第一个索引相同，则检查第二个索引，同样，小的在前，大的在后。  
如果第二个索引也相同，则看第三个。 

### 最左前缀原则
查询从索引的最左列开始。

### 如何安排联合索引里的索引顺序？
- 如果调整索引顺序，可以少维护一个索引，那么这个顺序是需要优先考虑的。

 
 




#锁 
##悲观锁
##乐观锁


#大数据量优化


#分表分库


#主从复制


#读写分离


#left join, inner join



#三范式


#判断索引执行顺序


#火车买票 多区间 设计表


#sql某列最大记录


#LevelDB原理，多路归并，读写放大
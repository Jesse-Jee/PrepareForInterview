# 数据库隔离级别
## 1 事务
事务是一些操作的集合，用专业术语讲，它是一个程序的执行单元。事务本身并不包含这4个特性，我们需要通过一些手段，尽可能的让执行单元满足这4个特性。
那么我们就可以称它为事务，或者说是一个正确的事务，完美的事务。

## 2 四大特性ACID
- 原子性：满足原子操作单元。要么全部成功，要么全部失败。
- 一致性：事务的开始和完成，数据都必须保持一致。
- 持久性：数据的修改是永久的。
- 隔离性：事务之间是相互独立的，中间状态对外不可见。

## 3 隔离级别
### 3.1 并发情况下事务引发的问题
一般情况下，多个操作单元并发执行，会出现这么几个问题
- 脏读：A事务还没提交，B事务就读到了A事务的结果。（破坏了隔离性）
- 不可重复读：A事务在本次事务中，对自己未操作的数据，进行了多次读取，结果出现了不一致或不存在的情况。（破坏了一致性，update和delete）
- 幻读：A事务在本次事务中，对自己未操作的数据，进行了多次读取，第一次读时，数据不存在，第二次读时，数据出现了。（破坏了一致性，insert情况）

### 3.2 引发问题的解决
为了权衡隔离和并发的矛盾，ISO定义了四个事务的隔离级别，每个级别的隔离程度不同，出现的副作用也不同。
- 读未提交（read-uncommitted）: 最低级别，只能保证持久性 
- 读提交 （read-committed）: 语句级别
- 可重复读（repeatable-read）: 事务级别
- 串行化（serializable）: 最高级别，事务与事务完全串行化执行，毫无并发可言，性能极低。  

| 级别 | 脏读 | 不可重复读 | 幻读 |  
| :---: | :---: | :---: | :---: |  
|Read uncommitted|	√|	√|	√|
|Read committed|	×|	√|	√|
|Repeatable read|	×|	×|	√|
|Serializable|	×|	×|	×|

### 3.3 实现（InnoDB）
- 锁机制：当一个事务在执行的时候，阻止其他事务对该事务进行操作。各个隔离级别主要体现在读取数据时加的锁和释放时机。
  - read-uncommitted: 事务读取时不加锁
  - read-committed: 事务读取时加行级锁（读到才加锁），一旦读完，立刻释放（并不是事务结束）
  - repeatable-read: 事务读取时加行级共享锁，直到事务结束才会释放。
  - serializable: 事务读取时加表级共享锁，直到事务结束才释放。
- MVCC机制：生成一个数据快照，并用这个快照来提供一致性的读取，也称为多版本数据控制。
  - 实际上就是CAS版本控制和读写分离的思想
  - 主要作用于 读提交和可重复读级别


#### 3.3.1 LBCC 基于锁的控制
- 乐观锁、互斥锁
- 意向锁
- 行锁
- 间隙锁
- 行锁+间隙锁
- 插入意向锁
- 自增锁
- 空间索引预测锁


#####  3.3.1.1 表锁与行锁区别
表锁相当于包酒店
行锁相当于包房间

- 锁定粒度： 表锁>行锁   
- 加锁效率： 表锁>行锁   
- 冲突概率： 表锁>行锁   
- 并发性能： 表锁<行锁  

##### 3.3.1.2 shared locks(行锁) 共享锁，读锁
对某个资源加共享锁，自身可以读该资源，其他人也可以读资源，但无法修改。要想修改需要等共享锁释放后。

加锁： select * from table **lock in share mode**;  
释放锁： commit\rollback;

##### 3.3.1.3 Exclusive locks（行锁） 排它锁
对某个资源加排它锁，自身可以进行增删改查，其他人无法进行任何操作。  
排它锁不能和其他锁共存。  

在任何数据上，只要你加了排它锁，别人都玩不了的。  

加锁： select * from table where id = 1 **for update**;  

释放锁：commit,rollback;
 

##### 3.3.1.4 Intention locks 意向锁
均为表锁，无法手动创建
- 意向共享锁
- 意向排它锁

###### 为什么要加入意向锁？
意向锁不是用来锁定数据的，而是告诉事务，当前已经有个人在占坑了。  
这样就不用一行一行扫描来确定有没有共享锁，有没有排它锁。  
而是直接看表的状态上有没有意向锁来判断我能不能创建一个表锁。  
说白了就是为了提高加表锁的效率

##### 3.3.1.5 自增锁
既满足加锁，又满足高并发的行为。  
级别有 0，1，2  
当innodb_autoinc_lock_mode=2时，效率是最高的。
默认用的是1
0 是表锁，满足123456递增的特性

#### 3.3.2 锁算法
##### 3.3.2.1 Record locks 记录锁
等值查询，精准命中就会使用记录锁
通过主键去查询某条记录，用的就是记录锁。

##### 3.3.2.2 Gap locks 间隙锁
开区间如（-∞，1）（1，5）（5，9）（9，11）（11，∞）  
间隙锁只存在于可重复读级别
间隙锁不排它，即在间隙锁的时候，我在某个记录上加排它锁，是成功的，即使这个记录不存在。


##### 3.3.2.3 Next-key locks 临键锁
就是间隙锁+记录锁
右闭区间，如（-∞，1]（1，5]（5，9]（9，11]（11，∞）

当查询区间正好在如 大于5小于9的时候，开启临键锁。




#### 3.3.3 MVCC
MVCC主要是为了提高并发的读写性能，不用加锁就能让多个事务并发。
相当于在开启某个事务的时候，对当前数据库里的数据拍个快照，一致性视图read-view。


innodb在begin事务时，会分配一个事务ID给事务，叫transaction_id，严格递增。  
如 1 age = 12    
事务A修改age=18，它会把事务的transaction_id赋值给这个版本事务ID，记到row_trx_id中。即 row_trx_id=transaction_id  
拍照拍的是什么？拍的是版本号，或者说是事务ID。


**Innodb+MVCC 一定程度上解决了幻读问题。通过多版本号。**  

##### 当前读
当前事务修改的数据，事务自己认不认？  
认。
这就破坏了快照读，所以叫当前读。  
但是当前读可能会一定程度导致幻读。    

# 索引
## 什么是索引？
索引就是帮助MYSQL高效获取数据的**排好序**的**数据结构**  

## 索引的数据结构
- 二叉树
- 红黑树
- hash表
- B树/B+树

### 二叉树
最坏情况可能造成单链表。  

### 红黑树
大数据量时，树的深度会太高，查找次数也会很多。

### B树
- 叶节点具有相同的深度，叶节点的指针为空
- 所有索引元素不重复
- 节点的数据索引从左到右递增排列


### B+树
- 非叶子节点不存储data，只存储索引，可以放更多索引。
- 叶子节点包含所有索引字段
- 叶子节点用指针连接，提高区间访问性能。





#锁 
##悲观锁
##乐观锁


##最左前缀原则



#大数据量优化


#分表分库


#主从复制


#读写分离


#left join, inner join


#B树、B+树


#三范式


#联合索引


#判断索引执行顺序


#火车买票 多区间 设计表


#sql某列最大记录


#LevelDB原理，多路归并，读写放大
# NAT  
## 1. 介绍  
NAT是network address translation的缩写，网络地址转换的缩写。
因为IP地址有限，所以需要多人共用一个公网IP来访问互联网。当需要访问互联网时，网络边界设备（路由器，防火墙等）将各个主机的私网IP地址，转成公网IP地址。
即，将数据包中的IP地址替换为其他IP地址的功能。
## 2. 实现方式  
### 2.1 静态NAT  
一个公网IP对应一个私网IP，一对一转换。
### 2.2 动态NAT  
在路由器上配置一个公网IP池，当私有IP要进行外部通信时，从池中选择一个公网IP，并将他们的关系绑定到NAT表中。通信结束后，这个公网IP才会被释放，供其他私有IP使用。

### 2.3 NAPT   
端口地址复用技术。是最常用的，提供一对多的方式。对外只有一个公网IP地址，内部通过端口来区分不同的私网IP主机数据。

## 3. NAT如何区分不同私网的host呢？ 
对于TCP/UDP使用
私网host + port <---> 公网host + port 

对于ICMP使用
私网host + sessionID <----> 公网host + sessionID

对于其他协议，NAT使用的也是类似的转换规则，选择将host能轻易区分出来的字段作为key值，动态创建映射表项，做双向地址+key的转换。

# ARP 
为IP地址到对应的硬件地址提供动态映射。

ARP请求（以太网广播） 问 某个地址的mac地址是多少啊？ 这个mac地址的给它单播返回告诉它。


# 1. ICMP 
IP层的一个组成部分。用于传递差错报文及其他需要注意的信息。
ICMP报文：
| 8位类型 ｜ 8位代码 ｜ 16位校验和 ｜  

## 1.1 查询报文类型
## 1.2 差错报文类型
ICMP差错报文的例子：
终点不可达为3；源抑制为4；超时为11；重定向为5。  
- 终点不可达
    - 网络不可达：主公，找不到地方呀？
    - 主机不可达：主公，找到地方没这个人呀？
    - 协议不可达：主公，找到地方，找到人，口号没对上，人家天王盖地虎，我说 12345！
    - 端口不可达：主公，找到地方，找到人，对了口号，事儿没对上，我去送粮草，人家说他们在等救兵。
    - 需要进行分片但设置了不分片位：主公，走到一半，山路狭窄，想换小车，但是您的将令，严禁换小车，就没办法送到了。
- 源抑制
  让源站放慢发送速度。

- 时间超时
  超过网络包生存时间
- 路由重定向
## 1.3 Ping 
ping是基于ICMP工作的。  
ICMP是封装在IP包里的。
ping就是**查询报文**，是一种主动请求，并且获得主动应答的ICMP协议。

假设同在一个子网，过程：
- 源主机首先构建ICMP请求数据包，类型为8，即查询，另一个为顺序号，主要用于区别连续ping发出的多个数据包，每发出一个，顺序号加1。
报文部分插入发送时间。
- ICMP协议将这个数据包连同地址一起交给IP层，IP层以地址为目的地址，本地IP地址为源地址，加上控制信息，构建IP数据包。
- 加入MAC头，如果早ARP映射表中能找到目的地址对应的mac地址，则直接使用，如果没有，则发送ARP请求查询mac地址。获得MAC地址后，由数据链路层构建数据帧。
目的地址是IP层传过来mac地址，源地址是本机的MAC地址。附加上控制信息，依赖以太网传输介质访问规则传送出去。

- 主机B接收到数据帧，先检查它的目的MAC地址，并和本机MAC做对比，如果符合则接收，不符合则丢弃。
- 接收后检查数据帧，将IP数据包从数据帧中提取出来，交给本机IP层，将有效信息提取后交给ICMP协议。
- 主机B构建ICMP应答包，应答包数据类型字段为0，顺序号为接收到的请求顺序号，然后发送回主机A。

在规定的时间内，源主机如果没有收到应答包，则说明主机不可达。
如果接收到了ICMP应答包，则说明主机可达，用当前时间减去最初发出的时间，即为数据延迟。 

  

## 1.4 traceroute 程序
**差错报文的使用**
- 故意设置特殊的TTL，来追踪去往目的地沿途经过的路由器。
- 故意设置不分片，从而确定路径的MTU
使用ICMP报文和IP首部的TTL字段（生存周期），TTL字段是由发送端初始设置的一个8bit字段。
ICMP设置的TTL最大是255

每个处理数据报的路由器都需要把TTL的值减1或减去在路由器中停留的秒数。
当路由器收到一份数据报的TTL是0或者1时，则路由器不转发这个数据报。路由器会把其丢弃，并给信源饥发送一个ICMP超时信息。

traceroute发送udp包给目的主机

# TCP
链路层：  
以太网：采用CSMA/CD的媒体接入方法。速率为10Mb/s，mac地址为48bit  
IEEE802：


封装格式：  
802.3:  
| 目的地址 6 ｜ 源地址 6 | 长度 2 | DSAP  1 | SSAP 1 | cntl 1 | org code 3 | 类型 2 ｜ 数据 38-1492 ｜ CRC 4 ｜  

以太网：  
| 目的地址 6 | 源地址 6 | 类型 2 | 数据 46-1500| CRC 4|  

IP协议：  
类型     IP数据报  
0800 

ARP协议：  
｜类型 ｜ ARP请求/应答 ｜ PAD ｜  
｜0806 ｜    26      ｜ 18

以太网头部： 目的地址  源地址 类型  
类型字段中，放协议，如上面的IP协议
以太网要求数据部分最少要求46字节，不足46字节的要用PAD补齐，超出1500字节的，要分页。  

应用层 FTP  21
传输层 TCP UDP
网络层 IP ICMP
数据层 

## TCP首部
- 16位源端口
- 16位目的端口
- 序号：用于对字节流进行编号。例如序号为301，长度为100字节，那么下个序号为401
- 确认号：期望收到的下一段报文的序号
- 数据偏移：首部的长度
- 控制位：
    - CWR：如ECE为1，则通知对方已将拥塞窗口缩小。
    - ECE：若为1，代表对方到这里的网络阻塞，在收到的IP首部中ECN为1时，将TCP的ECN设为1.
    - URG：为1时，表示有需要紧急处理的数据
    - ACK：为1时，确认应答字段有效。
    - PSH：为1时，将收到的数据立刻传给上层应用协议。为0时，将数据先缓存。
    - RST：为1时，表示TCP连接异常，必须强制断开连接。
    - SYN：用于建立连接
    - FIN：用于断开连接
- 窗口：作为接收方让发送方设置其发送窗口的依据。接收方的数据缓存空间是有限的。

## TCP 短连接，长连接区别
- 短连接：客户端给服务端发消息，服务端给客户端回消息。发起关闭，结束。
**建立的连接都是有用的连接。**
- 长连接：客户端和服务端完成一次读写后，不主动关闭，后续读写还用这个连接。
**连接数过多不关闭会给服务端压力。**

## 为什么常说 TCP 有粘包和拆包的问题而不说 UDP ？
UDP是基于报文发送的，UDP首部采用了 16bit 来指示 UDP 数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，
从而避免粘包和拆包的问题。而 TCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，
但是 TCP 并没有把这些数据块区分边界，仅仅是一连串没有结构的字节流；另外从 TCP 的帧结构也可以看出，在 TCP 的首部没有表示数据长度的字段，
基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。

## TCP粘包
客户端向服务端发送两个packet1，packet2
- 一种情况，正常接收到两个packet
- 一种情况，服务端接收到一个packet，1和2连到了一起
- 一种情况，服务端接收到了两个packet，但是一个大一个小，发生了粘包和拆包。

### 为什么会发生粘包，拆包？
- 要发送的数据大于TCP发送缓存区剩余空间的大小，会拆包。
- 待发送数据大于最大报文长度，会拆包。
- 要发送的数据小于TCP发送缓存区大小，TCP将多次写入缓冲区的数据一次发送出去，会粘包。
- 接收端应用层没有及时读取接收缓冲区的数据，会粘包。

### 粘包，拆包解决办法
TCP本身面向字节流，底层无法保证数据不被拆分和重组的。
只能通过上层的应用协议栈设计来解决。
- 消息定长：每个数据包固定长度，不足的用0补齐。
- 设置消息边界：服务端按消息边界分离消息内容。在包尾增加回车换行符进行分割。
- 将消息分为消息头和消息体：消息头中包含消息总长度。

## TCP滑动窗口
窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口。接收方通过TCP报文中的窗口字段告诉发送方自己的窗口大小。
发送方根据这个值和其他信息设置自己的窗口大小。
发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。
如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；
接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。
接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，
因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。


## TCP流量控制
控制发送方发送速率，保证接收方来得及接收。
窗口字段来设置。

## TCP拥塞控制
- 慢开始
- 拥塞避免
- 快重传
- 快恢复


## TCP能建立多少连接
- 客户端机：每个IP可以建立起的TCP连接，理论受限于ip_local_port_range参数，也受限于65535，但可以通过配置多个IP的方式加大建立连接的能力。
- 服务器机：每个监听的端口虽然理论值很大，但是最大并发取决于内存的大小，每一条静止状态的TCP连接大约吃3.3K的内存。假如内存是4G，
那么最大可接受的TCP连接是100万左右。 


# 1. SOCKET 
## 1.1 网络进程中如何通信
使用TCP/IP协议的应用程序通常使用socket来进行网络通信。
### 1.1.1 如何确定唯一标识？
网络层 IP地址+ 传输层 协议+端口 可以唯一标识主机中的应用程序。

### 1.1.2 什么是socket
socket就像是一种特殊的文件，一些socket函数对其进行操作（读写i/o，打开，关闭）

### 1.1.3 socket的基本操作
#### 1.1.3.1 socket()函数  
创建一个socket描述符，唯一标识一个socket。后续操作通过它进行一些读写操作。  
**int socket(int domain, int type, int protocol);**  
创建socket时可以指定不同的参数
- domain：协议域；AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，
在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。
- type：socket类型。SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等  
- protocol：协议。IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，
它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议。  

当我们调用socket()时，返回的socket描述字存在于协议域空间中。如果想给它赋一个地址，就必须调用bind()函数。  

##### 1.1.3.1.1 socket类型有哪些？
SOCK_STREAM，SOCK_DGRAM，SOCK_RAW，SOCK_PACKET，SOCK_SEQPACKET。


#### 1.1.3.2 bind()函数  
把一个地址族中的地址赋值给socket。   
**int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);** 
- sockfd 即socket描述字
- sockaddr 指向要绑定给socket的协议地址，指针。根据地址协议族的不同而不同。
- addrlen 地址长度

通常服务器在启动时会绑定一个众所周知的地址（如IP地址+端口号）用于提供服务，客户端可以通过IP地址加端口号连接服务器。而客户端不用指定。
由系统自动分配一个端口号和自身IP地址的组合。这就是为什么通常服务器在listen之前需要调用bind，而客户端不用调用，而是在connect时由系统随机生成一个。

#### 1.1.3.3 listen()函数
调用listen监听这个socket，这时如果客户端调用connect发出连接请求，服务器就会接收到这个请求。
**int listen(int sockfd, int backlog);**
- sockfd 即要监听的socket描述字
- backlog 即相应socket可以排队的最大连接个数。
socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。  

**int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);**

- sockfd 即客户端socket描述字
- addr 即服务器socket地址。
- addrlen 即socket地址长度

客户端通过connect函数与TCP服务端建立连接。

#### 1.1.3.4 accept()函数
TCP服务器在经过socket,bind,listen后，监听端口，当监听到连接请求后，调用accept进行连接。之后就可以进行网络i/o操作了。
就像对文件i/o的操作一样。  
**int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);**
- sockfd 服务器socket的描述字
- addr 返回客户端的协议地址
- addrlen 协议地址长度


#### 1.1.3.5 read/write 等函数
万事具备，只欠i/o操作。
- read()/write()
- recv()/send()
- readv()/writev()
- recvmsg()/sendmsg()
- recvfrom()/sendto()


       ssize_t read(int fd, void *buf, size_t count);
       ssize_t write(int fd, const void *buf, size_t count);
       ssize_t send(int sockfd, const void *buf, size_t len, int flags);
       ssize_t recv(int sockfd, void *buf, size_t len, int flags);
       ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
                      const struct sockaddr *dest_addr, socklen_t addrlen);
       ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                        struct sockaddr *src_addr, socklen_t *addrlen);
       ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);
       ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);

read函数是负责从fd中读取内容.当读成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。
如果错误为EINTR说明读是由中断引起的，如果是ECONNREST表示网络连接出了问题。
write函数将buf中的nbytes字节内容写入文件描述符fd.成功时返回写的字节 数。失败时返回-1，并设置errno变量。
在网络程序中，当我们向套接字文件描述符写时有俩种可能。1)write的返回值大于0，表示写了部分或者是 全部的数据。2)返回的值小于0，此时出现了错误。
我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示 网络连接出现了问题(对方已经关闭了连接)。



#### 1.1.3.6 close()函数
关闭相应socket描述字
close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。




# 1. UDP 
## 1.1 什么是UDP
- UDP是一个简单的面向数据报的运输层协议：进程的每个输出操作，都正好产生一个UDP数据报，并组成一份待发送的IP数据包。
- UDP不提供可靠性：它把应用程序传给IP层的数据发送出去，但是并不能保证它们到达目的地。
- 应用程序必须关心IP数据报的长度，如果它超过网络的MTU，那就要对IP数据报进行分片。

## 1.2 UDP的封装
![Image text](https://raw.githubusercontent.com/jizengguang/PrepareForInterview/master/Picture/udp.png)

## 1.3 UDP的三大应用
- 查询类：DNS
  - 没有TCP的三次握手过程，快
  - 多个DNS同时查询
- 数据传输：TFTP
  - 停止等待协议，慢
  - 适合于无盘工作站
- 语音视频流：
  - 支持组播和广播
  - 支持丢包，保障效率
  
## 1.4 UDP首部
![Image_text](https://raw.githubusercontent.com/jizengguang/PrepareForInterview/master/Picture/udp_header.png)


只有8个字节
- 16位源端口号
- 16位目的端口号
- 16位UDP长度
- 16位UDP校验和
- 数据

## 1.5 UDP校验和
- UDP校验和覆盖UDP首部和UDP数据
- IP校验和只覆盖IP首部
- UDP的校验和是可选的，而TCP的校验和是必需的。

## 1.6 IP分片
- IP把MTU和数据报长度进行比较。
- 把一份IP数据报分片以后，只有到达目的地才进行重新组装。
- 重新组装由目的端的IP层来完成，其目的是使分片和重组过程对运输层（TCP、UDP）透明
- 已经分片过的数据报有可能会再次进行分片。

- 在分片时，除最后一片外，其他每一片中的数据部分（除IP首部外的其余部分）必须是8字节的整数倍。
- IP首部被复制到各个片中，但是端口号在UDP首部，只能在第一片中被发现。

# TCP UDP区别
类型：面向连接：传输可靠性：传输形式：传输效率：所需资源：应用场景：首部字节  
TCP：面向连接，可靠，字节流，慢，多，文件传输/邮件传输，20-60  
UDP：无连接，不可靠，数据报，快，少，视频，音频，8  


# OSI体系结构
应用层
表示层
会话层
运输层
网络层
数据链路层
物理层


# 五层协议结构
应用层 FTP/DNS/HTTP协议
运输层 TCP/UDP
网络层 IP
数据链路层
物理层

## 各层作用
### 应用层
通过应用进程间的交互，完成特定的网络应用。

### 运输层
负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程通过利用该服务传送应用层的报文。

### 网络层
在网络中通信的两个计算机之间可能会经过很多数据链路，网络层就是选择合适的网间路由和交换节点，确保数据传送。

### 数据链路层
两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议。在两个相邻节点之间传送数据时，
数据链路层将网络层交下来的IP数据报组装称帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息。

### 物理层
在物理层传送的数据单位是比特，物理层作用是实现相邻计算机节点之间的比特流的透明传送，尽可能屏蔽掉传输介质和物理设备的差异。


## DNS
域名系统，将域名与IP地址相互映射。
## HTTP
超文本传输协议

# 三次握手
客户端： 发送带SYN标志的数据包，例如SYN J 第一次握手
服务端： 接收到SYN标志的数据包，返回给客户端 SYN K , ACK seq J+1 ，带ACK意思是这是一个应答包
客户端： 接收到服务端返回的SYN/ACK数据包，返回给服务端 ACK K+1

![Image_text](https://raw.githubusercontent.com/jizengguang/PrepareForInterview/master/Picture/three_hand.png)

## SYN和ACK
SYN是同步序列号，是TCP/IP建立连接时使用的握手信号。
ACK是确认字符，在数据通信中，接收站发给发送站的一种传输类控制字符。表示发来的数据已确认接收无误。

## 为什么需要三次握手？
保证数据的正常发送与接收
第一次握手，客户端无法确认；server端确认对方发送正常，自己接收正常。
第二次握手，客户端确认自己发送，接收正常，对方发送接收正常；server端确认对方发送正常，自己接收正常。
第三次握手，客户端确认自己发送，接收正常，对方发送接收正常；server端确认对方发送接收正常，自己发送接收正常。

# 四次挥手 
- 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），
此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
- 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。
TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，
客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
- 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
- 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，
假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
- 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。
注意此时TCP连接还没有释放，必须经过2MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
- 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。
![Image_text](https://raw.githubusercontent.com/jizengguang/PrepareForInterview/master/Picture/four_hands.png)

## 四次挥手中，服务器端的Close-Wait有什么用？
用于将最后的数据发送完毕，再向客户端发送连接释放报文。

## 四次挥手中，为什么客户端需要等待2MSL？
第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，
客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，
接着给出回应报文，并且会重启2MSL计时器。
第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，
就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。
 
 
# TCP协议如何保证可靠传输
1. 应用数据被分割称TCP认为合适发送的数据块。
2. TCP会给发送的每个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
3. 校验和：TCP将保持它首部和数据的校验和，目的是检测数据在传输过程中的变化。如果收到的校验和有差错，将丢弃此报文段和不确认收到此报文段。
4. TCP的接收端会丢弃重复的数据。
5. 流量控制： TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，
能提示发送方降低发送速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。
6. 拥塞控制：当网络拥塞时，减少数据发送。
7. ARQ协议：每发完一个分组就停止发送，等待对方确认，在收到确认后再发下一个分组。
8. 超时重传：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。


# 无类型域间选路 CIDR
将32位的IP地址一分为二，前面是网络号，后面是主机号。
10.100.122.2/24 斜杠后面的数字代表前24位是网络号，后8位是主机号。

伴随CIDR存在的是广播地址，10.100.122.255，如果发这个地址，10.100.122网络里的机器都可以收到。另一个是子网掩码255.255.255.0。
将子网掩码和IP地址进行AND计算，就可以得到网络号



# TCP keepalive机制
## 为什么需要keepalive
服务端和客户端网络一切正常，且双方都没有主动发起关闭连接的请求时，此TCP连接理论上可以永久保持。  
但是，网络情况是很复杂的，在双方长时间未通信的时候，如何知道对方还活着？
如何得知这个TCP连接还是健康且可以通信的？

保活机制默认是关闭的。TCP连接的任意一方都可以打开此功能。有三个主要配置参数用来控制保活功能。

如果在一段时间（tcp_keepalive_time）内连接都不活跃，开启保活功能的一端会向对端发送一个保活探测报文。
- 如果对端正常，且连接有效，收到报文会进行回应。证明TCP连接正常，重置保活时间计数器。
- 如果由于网络或其他原因导致发送端无法收到保活探测报文的响应。在一定探测时间间隔（tcp_keepalive_intvl）后，将继续发送保活探测报文，
直到收到对端回应或者达到配置的探测循环次数上限（tcp_keepalive_probes）都没有收到对端响应。这时候认为对端不可达，TCP连接失效，
需要将连接中断处理。  

| 状态 | 处理 |  
| :---: | :---: |  
|对方主机仍在工作，且可达|连接正常，保活计数器重置|
|对方主机已崩溃，包括：正在关闭或重启|连接不正常，经过指定次数探测没有得到响应，断开连接|
|对方主机已崩溃，且已重启|重启后原连接失效，请求端将连接断开|
|对方主机仍在工作，但因某些原因不可达|连接不正常，经过指定次数探测没有得到响应，断开连接| 

# HTTP keep-alive机制
客户端的每一次请求都要和服务器端创建TCP连接，服务器响应后，断开TCP连接。下次再有客户端请求，再连接。

http1.0默认是关闭的，通过http请求头设置“connection: keep-alive”进行开启；
http1.1中默认开启，通过http请求头设置“connection: close”关闭。

若开启后，在一次http请求中，服务器进行响应后，不再直接断开TCP连接，而是将TCP连接维持一段时间。在这段时间内，
如果同一客户端再次向服务端发起http请求，便可以复用此TCP连接，向服务端发起请求，并重置timeout时间计数器，
在接下来一段时间内还可以继续复用。这样无疑省略了反复创建和销毁TCP连接的损耗。

# 1. HTTP

## 1.1 一次URL如何工作
浏览器输入网址URL，浏览器将域名发送给DNS解析，将域名解析称IP地址，然后通过三次握手建立TCP连接，建立连接后，浏览器发送HTTP请求。  
请求的格式见**1.2 HTTP请求报文**；此时我们拼凑完了http请求的报文，接下来，浏览器会将它交给传输层，怎么交给传输层呢？通过socket.
HTTP协议是基于TCP协议的，使用面向连接的方式发送，通过stream二进制流的方式传给对方。到了TCP层，会将二进制流变成一个个报文段发送给服务器。
在发送每个报文时，都需要对方有ack回应，如果没有回应，TCP这一层将重传，直到可到达。
TCP层每次发送报文时，都要加上自己的源地址和目的地址，放到IP头里，交给IP层传输。
IP层查看目的地址和自己是否在一个局域网中，如果是，就用ARP协议找到对应的Mac地址，将源Mac地址和目的Mac地址放到Mac头中，发送出去。
如果不在同一个局域网中，就发送到网关，当然，也需要用ARP获取到网关的MAC地址，将网关Mac地址和目的Mac地址放到Mac头发送出去。
网关收到包，发现Mac头符合，取到目的IP地址，根据路由协议找到下一跳的路由器，获取下一跳路由器Mac地址，将包发送给下一跳路由器。
这样不断跳直到找到目标地址的局域网。最后一跳的路由器发现，目标地址在自己某个出口的局域网上，于是通过ARP获取到目的地址的Mac，将包发过去。
目的地址发现Mac地址符合，解析包，发现IP地址符合，根据IP头中协议，知道用的是TCP协议，解析TCP的头，里面有个序列号的头，看一下这个序列包是不是我要的，
是的话，就应答一个ACK,不是就丢弃。
TCP头中还有端口号，HTTP服务器正在监听这个端口，于是将包发给HTTP服务器，HTTP服务器发现，哦，原来时想要访问个网页，于是把网页发给客户端。


## 1.2 HTTP请求报文
分为三部分。  
![Image_text](https://raw.githubusercontent.com/jizengguang/PrepareForInterview/master/Picture/http_header.png)  

- 请求行
    - 方法：GET/POST/...
        - GET： 去服务器获取一些资源，返回是页面还是json等等的由服务器端决定。
        - POST：主动告诉服务器一些信息，一般会把信息放在正文里面。常见的格式是json。
        - PUT：向指定资源位置上传最新内容。 实际使用中，一般用POST来创建一个资源，用PUT来修改资源。
        - DELETE：删除资源
    - 版本：HTTP 1.1/2/3
- 首部
    - 首部字段名：key value形式
        - Content-Type：正文格式
        - Accept-Charset：可接受字符集
        - Cache-Control: 控制缓存
            - 对于静态资源，有vanish缓存层，当缓存过期时，才会访问真正的tomcat集群。
            - 当客户端发送的请求中包含max-age指令时，如果判定缓存层时间数值比指定数值小，那么可以接受缓存资源，如果max-age为0，则转发到集群。
            
- 实体

## 1.3 HTTP1.1 缺陷
- 高延迟-队头阻塞：顺序发送的请求序列中，因为某种原因被阻塞时，后面排队的所有请求也被一并阻塞，导致客户端迟迟收不到数据。
- 无状态特性-阻碍交互：对连接状态没有记忆能力。上一次请求验证了用户名密码，下一次不知道与上一次有何关联。
- 明文传输-不安全：内容无加密
- 不支持服务端推送

## SPDY协议
**由谷歌推行的改进版本的HTTP1.1**
- 多路复用，解决队头阻塞
    - 一个连接上无限并发流，更少的网络连接，发出更密集的包。
- 头部压缩，解决巨大头部
    - HPACK算法，每次请求和响应，只发送差异头部。
- 请求优先级，先获取重要数据
    - 网络资源被非关键资源阻塞时，高优先级优先处理
- 服务端推送，填补空白
    - 主动把资源文件推送给客户端
- 提高安全性
    - 支持使用HTTPS

## 1.4 HTTP2
基于SPDY协议，专注于性能。
- 二进制分帧
    - 分帧：没有改变HTTP的语义，在应用层使用了二进制分帧方式传输。因此引入了新的通信单位，帧、消息，流
    - 分帧的好处：单位时间接收到的请求变多，可以提高并发数。为多路复用提供了底层支持。
- 多路复用
    - 一个域名对应一个连接，一个流代表了一个完整的请求-响应过程。帧是最小数据单位，每个帧会识别出属于哪个流。流也是多个帧组成的数据流。
       多路复用就是一个TCP连接中可以存在多个流。


## 1.5 HTTP2缺陷
- TCP以及TCP+TLS建立连接的时延
    - 三次握手，需要消耗1.5个RTT才能进行数据传输。RTT：往返时延
- 队头阻塞没有完全解决
    - TCP为了保证可靠传输，有超时重传机制，丢失的包必须等待重传确认。
- 多路复用导致服务器压力上升
    - 没有限制同时请求数，可能导致瞬时QOS暴增。
- 多路复用导致容易timeout 
    - 带宽资源有限  
    
## 1.6 QUIC，也就是HTTP3
**基于UDP协议的QUIC协议**
- 改进的拥塞控制，可靠传输
    - 可插拔-应用程序层面实现不同的拥塞控制算法
    - 单调递增的Packet Number-使用packet number代替TCP的seq。就算丢失了，重传的packet N也不再是N，而是比N大的数值。
    - 不允许数据丢弃，只要被ACK，就认为它一定被接收。
    - 更多的ACK块和增加ACK Delay时间。同时提供256个ACK BLOCK。
    - 基于流和连接级别的流量控制
- 快速握手
    - 因为是基于UDP的
- 集成TLS1.3加密
    - 支持三种基本秘钥交换模式：（EC）DHE，PSK-only，PSK with （EC）DHE
    - 在完全握手情况下，需要1RTT建立连接，恢复会话不需要额外的握手，也就是0RTT
- 多路复用
    - 携带个别流的数据包丢失时，只影响该流
- 连接迁移
    - TCP是按照客户端IP，端口，服务器端IP，端口来确定一个连接的，而QUIC是让客户端生成一个connection ID(64)位来区别不同连接，
    只要ID不变就不需要重新连接。


# HTTPS
在HTTP基础上再加一层TLS，为了应对HTTP明文传输的缺点。TLS在应用层。

明文传输容易被窃听。
## 怎么防止被窃听和篡改呢？
加密啊
### 对称加密
加密解密同时运用同一个密钥。
如果密钥被劫持了，这不暴露了吗？
于是需要非对称加密。
### 非对称加密
加密解密用的不是同一把钥匙。
任何人都可以拿到A公开的公钥内容进行加密，但只有A能自己的私钥才能解密。



HTTPS的加密方式结合了对称加密和非对称加密，使用非对称加密对密钥进行加密，然后对报文数据进行对称加密。
这时还是有可能出现问题，中间人拿到数据后，使用自己的密钥解密，再用自己的密钥加密进行偷天换日。

因此引来信任危机，由此引入数字签名。

## CA
让CA给自己一张身份证，这张证书中有A的公钥和CA的数字签名。

## 数字签名是通过什么措施验证公钥来源的？
1. 服务端把报文经过hash处理生成摘要信息digest，摘要信息使用私钥加密生成签名，服务器把签名连同报文一起发送给客户端。
2. 客户端收到后，把签名提取出来，用公钥解密，如果能正常解密出来digest，那就确认是对方发的。

## 为什么公钥解密就能确认是对方发的？
因为私钥是CA提供的，我们相信CA。

解决了密钥传输，认证问题，那黑客可以乱改数据啊。

## 验证数据完整性
客户端把报文text取出做hash处理，得到摘要信息digest，再与之前用公钥解密后的digest对比，如果两者相等，表示内容未篡改。
只要数据被动过了，hash就不可能获取到同样的digest，这就是为什么要用hash的原因。


## 小结
安全可靠的保障：
- 对称加密和非对称加密的应用
- 证书，数字签名解决信任问题
- hash解决数据完整性问题。

## HTTPS的工作过程
1. client hello  
客户端向服务端发送hello信息，这个信息里包括客户端生成的随机数random1，客户端支持的加密套件和ssl version信息。
2. server hello  
服务端向客户端发送hello信息，这个信息会从客户端发送过来的 支持的加密套件中确认一份加密套件，这个决定了后面加密和生成摘要时具体使用哪个算法。
另外生成随机数random2。这样客户端和服务端都拥有了两个随机数。
3. certificate
服务端将自己的证书下发给客户端，让客户端验证自己的身份。
客户端验证通过后取出证书中的公钥。
4. certificate verify  
客户端收到服务端发来的证书后，向CA验证证书的合法性，验证通过后，取出服务端公钥，再生成一个随机数random3，再用服务器公钥非对称加密
random3，生成preMaster key。
5. client key exchange
客户端将preMaster key 传给服务端，服务端用自己的私钥解出random3，至此，客户端和服务端都有了random1，random2，random3。
两边根据同样的算法生成一份私钥，握手结束后的应用层都用这个私钥进行对称加密。

**为什么要三个随机数？**
因为SSL/TLS 握手的过程数据都是明文传输的。使用多个随机数种子，不容易被暴力破解。

6. Encrypted Handshake Message(Client)
这一步对应的是 Client Finish 消息，客户端将前面的握手消息生成摘要再用协商好的秘钥加密，这是客户端发出的第一条加密消息。
服务端接收后会用秘钥解密，能解出来说明前面协商出来的秘钥是一致的。

7. Change Cipher Spec(Server)

这一步是服务端通知客户端后面再发送的消息都会使用加密，也是一条事件消息。

8. Encrypted Handshake Message(Server)
这一步对应的是 Server Finish 消息，服务端也会将握手过程的消息生成摘要再用秘钥加密，这是服务端发出的第一条加密消息。
客户端接收后会用秘钥解密，能解出来说明协商的秘钥是一致的。

9. Application Data
到这里，双方已安全地协商出了同一份秘钥，所有的应用层数据都会用这个秘钥加密后再通过 TCP 进行可靠传输。



# HTTP重定向机制



# Session，Cookie区别


# 网络协议栈


# DNS协议解析过程






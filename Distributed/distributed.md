# 一致性raft算法
- 主从同步
    - master接收写请求
    - master复制日志到slave
    - master等待，直到所有slave返回。

缺点： 一个slave挂了，master阻塞，集群不可用。保证了一致性，可用性降低。      

## 什么是分布式共识
一个客户端向单独一个节点发送数据，两者很容易就数据达成共识。
当我们有多个节点的时候呢？                  

## raft
强一致性算法，用于分布式共识的协议工具
主要完成三件事：
- leader选举
- 日志复制
- 保证分布式共识


一个节点可能有三种状态：leader， follower， candidate         

**leader选举**
- 所有节点一开始都是follower状态。
- 如果follower没有收到leader的信息，就可以变成候选人。
- 候选人请求其他节点给自己投票
- 如果获得超过半数投票，那么候选人变成leader。


**raftleader选举复杂情况**

- raft中有两个超时设置可以控制选举
- 当选举超时（follower成为candidate之前要等待的时候）时，选举超时的时间随机分配在150Ms到300Ms之间。
- 首先超过超时时间的follower成为候选人，先把自己的vote count +1，自己投自己，同时让大家投票。见上。
- 如果在接收到请求的时候，node还没投过票，那么就把票投给这个候选人，并且重置超时时间。
- 一旦选举人获得超过半数投票，就成为leader。
- leader向follower发送添加条目信息
- 这些消息以心跳超时的时间间隔发送
- follower响应添加条目请求，接收到请求同时重置超时时间。直到接收不到leader心跳为止。


一种异常情况：
- 如果两个node同时成为了候选人，那么会发生拆分表决。
- 两个节点相同时间开始进行选举，每个都先到达一个节点。然后每人都得了相同票数。
- 节点就会等待一个超时周期，重新发起选举。      
- 获得超半数的node投票成为leader



系统所有改变都要经过leader。

**日志复制**      

- 客户端给leader节点发送信息
- 每个信息都会添加为节点的log条目
- log条目没有提交就不会更新node的值
- leader将条目保存，并在下个心跳周期将条目发送到follower节点
- leader等待大多数节点都写入了该条目的反馈
- leader中值修改成功，返回给客户端response。然后通知follower已提交。
- 集群达成共识。

在面临网络分区时，raft仍然能保持一致。
- 可能会造成有两个leader的局面。
- 当客户端发送信息给其中一个leader时，因为不能发送到绝大多数node上，所以信息保持未提交。
- 另一个客户端发送消息给另一个leader试图修改某个信息时，可能会成功，因为可能这个leader掌握大多数node。

当分区结束，网络恢复了，两个leader如何处理呢？
- 掌握少数node的leader看到一个大佬leader更高的选举期然后退出。
- 这些少数派将回滚未提交的条目并匹配新领导的log。
- 集群恢复如初。


# 一致性hash算法

## 为什么需要？
Redis集群使用了一致性hash算法。            
为了保证Redis的高可用，最简单的我们会进行主从复制和读写分离。对Redis采用集群的方式进行读写分离。               
那么我们在查找时，如果进行了分库操作，数据不在一个数据库上，怎么确定要到哪去找呢？全部查几次显然不科学。            
那么就按照分库分表的规则，按照hash值，取模、按照类别、按照某个字段值等常见规则就可以筛选出来。               
这个也只是解决了筛选出来的情况，服务器数量有增减的时候就不行了。那么，一致性hash应运而生。                         

## 一致性hash算法原理
将整个哈希值空间组织成虚拟的圆环。从0开始，到2^32。
一致性hash算法也是使用取模的方法，与2^32取模。


1. 对缓存集群中节点某个属性求hash值，放到环上。              
2. 数据要写入时，对数据进行hash运算，拿到hash值，放到环上，到环上的位置就是落点，到落点后沿着顺时针顺序，找到第一个服务节点的位置，
    就把自己的数据放到这个服务节点的cache中去。                                 
3. 创建尽可能多的虚拟节点，来保证分布均匀， 创建虚拟节点时发生hash碰撞要及时处理。                                     


新加节点对已有节点产生的影响是一致的，一致性hash。                     


    
# 分布式事务
分布式系统中实现事务          
事务，ACID。                    

## 分布式事务实现方式
1. 2PC 二阶段提交，强一致性设计。同步阻塞协议。是一种尽量保证强一致性的分布式事务。数据库层面。                                                    
    引入事务协调者角色。二阶段分为准备和提交。                   
    - 准备阶段：                 
        协调者给各参与者发送准备命令（除了提交事务之外啥事都做完了），如果有失败，第二阶段就执行回滚。                 
    - 提交阶段：                     
        同步等待所有参与者响应，提交或者回滚（准备阶段有出错的就回滚）。                     
        如果第二阶段失败。
         - 回滚的话，不断重试。           
         - 提交的话，不断重试。               
    
    - 存在的问题：                    
        - 协调者故障        
        - 同步阻塞效率差
        
2. 3PC 三阶段提交，解决2PC的一些问题，参与者中添加超时机制。数据库层面。                        
    准备阶段，预提交阶段，提交阶段。                    
    - 准备阶段：                     
        只检查参与者们的状态是否正常。                     
    - 预提交阶段：                                
        与2PC准备阶段一样，把除提交外所有事情都做完。                            
    - 提交阶段：                             
        与2PC提交阶段一样。                     
        
    无论哪个阶段有参与者返回失败，都会宣布失败。                      
    预提交阶段保证至少在准备阶段所有参与者都回应了。                        
    等待提交命令超时，那么参与者就会提交事务。                           
    等待预提交命令超时，参与者该干嘛干嘛。                             
    这样就会造成数据不一致的情况，如果执行的是回滚，参与者却提交了。                                         
    
    交互时间更长，性能下降，问题没解决，还是存在数据不一致情况。（3PC只是理论上的东西）                                  
    
    
3. TCC 业务层面分布式事务  
    TCC有事务管理者角色，用于记录全局事务状态并提交或者回滚事务。                                                                                    
    - 预留: 资源的预留和锁定                                      
    - 确认: 真正执行                
    - 撤销: 把预留动作撤销               
    
    先对各个参与者执行预留动作，如果都预留成功，就执行确认，如果有失败就撤销。                                     
    对业务侵入和业务耦合，但TCC可以跨数据库、跨不同业务系统来实现事务。                           

4. 本地消息表
    存放一张本地消息表到数据库中，将业务的执行和消息放到消息表操作放在同一个事务。 
    如果调用失败，后台任务定时读取本地消息表，筛选未成功的再调用对应服务。                 
    本地消息表实现的是最终一致性，容忍数据暂时不一致情况。                 
5.  消息事务                
    RocketMQ
    第一步先给 Broker 发送事务消息即半消息，半消息不是说一半消息，而是这个消息对消费者来说不可见，然后发送成功后发送方再执行本地事务。                           
    再根据本地事务的结果向 Broker 发送 Commit 或者 RollBack 命令。
    
    并且 RocketMQ 的发送方会提供一个反查事务状态接口。如果一段时间内半消息没有收到任何操作请求，
    那么 Broker 会通过反查接口得知发送方事务是否执行成功，然后执行 Commit 或者 RollBack 命令。                      
                                    
    如果是 Commit 那么订阅方就能收到这条消息，然后再做对应的操作，做完了之后再消费这条消息即可。                  
                                 
    如果是 RollBack 那么订阅方收不到这条消息，等于事务就没执行过。                        
                                  
    可以看到通过 RocketMQ 还是比较容易实现的，RocketMQ 提供了事务消息的功能，我们只需要定义好事务反查接口即可。
    
    消息事务实现的也是最终一致性。                     
    
                            
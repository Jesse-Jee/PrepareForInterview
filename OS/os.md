# 进程、线程
## 进程 & 线程
参考：
[进程与线程总结](https://zhuanlan.zhihu.com/p/86629244)
###   进程  
进程是操作系统资源分配的基本单位。
一个程序在系统上运行时，就是一个进程。
每个进程都有自己的虚拟地址空间，虚拟地址空间划分为内核空间和用户空间。操作系统运行在内核空间，内核空间由所有进程的地址空间共享。
用户程序不能直接访问内核空间，操作系统保存的进程控制信息在内核空间中。  
进程控制信息PCB中包含：  
- 页目录  
- 父进程ID
- 状态
- 句柄表
- 等等

###   线程  
线程是进程中的执行体，它会有指定的执行入口，通常是某个函数的指令入口。线程执行时要使用从进程虚拟空间中分配的栈空间来存储数据。
被称为线程栈。在创建线程时，操作系统会使用用户空间和内核空间分别分配两段栈，就是通常所说的用户栈和内核栈。线程切换到内核态时会使用内存栈。
是为了不允许用户代码对其进行修改以保证安全。操作系统也会保存每个线程控制信息。
线程控制信息TCB包括：
- 执行入口
- 线程栈
- 线程ID 
- 等等


在PCB中有进程拥有的线程列表。同一个进程中的线程，会共享进程的地址空间和句柄表等资源。
在linux中，使用的是task_struct结构体保存进程和线程控制信息。进程在创建子进程时，会指定它和自己使用同一套地址空间和句柄表等资源。
用这种方法来实现多线程的效果。


###  为什么说线程是操作系统调度与执行的基本单位。  
如果CPU要执行进程中的线程，CPU的指令指针会指向线程的执行入口。当前执行用户空间的程序指令，栈基ebp和栈指针寄存器esp会记录用户栈的位置。
CPU面向的是某个线程，所以才说，线程是操作系统调度与执行的基本单位。


###  进程与线程的关系  
一个进程中至少有一个线程，这个线程叫做主线程，可以认为它是进程中的第一个线程，一般是由父进程或操作系统创建的。  
进程中的其他线程，一般都是由主线程创建的。


- 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程是操作系统可识别的最小执行和调度单位
- 资源分配给进程，同一进程的所有线程共享该进程的所有资源。 同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。
但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量
- 处理机分给线程，即真正在处理机上运行的是线程
- 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步



###  用户态和内核态的转变  
线程中发生函数调用时，会在线程栈中分配函数调用栈，而虚拟内存分配，文件操作，网络读写等功能都是由操作系统来实现的，再向用户暴露接口。
所以线程免不了调用操作系统提供的系统服务。CPU中有特权级的标识，用于记录当前程序执行在用户态还是内核态，只有标识为内核态是，才能访问内核空间。
当系统调用发生时，线程会使用内核栈，执行内核空间的系统函数。这被称为从用户态切换到内核态。
最初，系统调用是通过软中断来实现的，所谓软中断，就是通过指令来模拟中断。
还有一个是硬中断，CPU会在内存中存一张中断向量表，用来把这个中断编号映射到相应的处理程序。例如Linux系统中，系统调用中断对应的编号为0X80，
对应的处理程序就是用来派发系统调用的。系统调用太多，不能每个都分配一个编号，于是操作系统又实现了一张系统调用表，用于通过系统调用编号找到对应
系统函数入口。

用户程序会把要调用的系统函数编号存入特定寄存器，通过寄存器或用户栈来传递其他所需参数，然后用 int 0x80来触发系统调用中断。
在硬件层面上，CPU有一个中断控制器，负责接收中断信号，切换到内核态，保存用户态执行现场。
后来，改为使用特殊指令触发系统调用，例如，syscall，当CPU执行到这些指令时，就会陷入内核态，从专用寄存器中拿到派发入口地址。
省去了查询中断向量表的过程。等系统调用完成后，再利用之前保存的信息，恢复线程在用户态的执行现场。


###   线程切换和进程切换
1. 同进程的线程a1 切换到线程a2，只涉及线程切换，只需要将a1的执行现场保存下来，再把指令指针，栈指针等寄存器的值修改为线程a2，
修改内存中调度相关的数据结构，就完成了同进程间的线程切换。等到a1时间片恢复后，根据之前保存的执行现场，恢复即可。
2. 从进程A的线程a1切换到进程B的线程b1，将CPU保存的页目录地址换为B的。

进程空间切换和线程空间切换的区别就是，进程间切换会导致地址空间等进程资源发生变化，会导致TLB缓存失效，代价更大。


##   什么是虚拟内存
DOS时期，进程使用内存是直接使用物理地址，因为进程会修改地址上的信息，不同进程可能造成内存修改冲突。
甚至可能会覆盖操作系统使用的内存，后来，出现了保护模式，内存使用虚拟内存而非物理内存。操作系统负责把虚拟内存映射到物理内存上。

如何映射？
保护模式提供物理内存分页，把物理内存中的每4KB作为一页。从虚拟内存到物理内存以页为单位映射。
操作系统会以链表的形式记录各个进程的控制信息，在window中叫内存控制块，Linux中叫task_struct。每个进程的控制信息中都有一个这样的指针，
记录当前进程"页目录"的物理地址。页目录也是一个内存页，存储的是一系列指针，指向同样用来存储物理内存页起始地址的"页表"。

在32位CPU下，一个地址占4个字节，一个页目录就可以寻址1024个页表，而每个页表又可以寻址1024个物理内存页，每个页4K。
因此， 1024 * 1024 * 4K = 4GB

线性地址：
前10位从页目录中选择一个页表。
中10位从页表中锁定一个物理内存页。
后12位存储一个相对内存页起始地址的偏移量。
这样就实现了一个虚拟内存到一个物理内存的映射。

这样就可以让不同进程使用不同的物理地址，也可以让两个进程使用同一块物理地址实现共享内存。


页表中的记录：
内存页大小都是4KB，所以内存页的地址一定是4K的整数倍，也就是说，它的低12位一定是0。因此页表中的每一条记录都有一个12位的空闲空间可以使用。
它们可以用来标识对应物理内存页是否可读可写可执行等信息，其中一位用于标识物理内存页是否已经映射。

###  进程向操作系统申请映射的内存   
通常不会一申请就立马分配。
进程拿到的是线性地址，CPU拿到的自然也是线性地址，线性地址的转换会交由CPU中MMU模块完成。当前进程持有的页目录的物理地址会被保存到特定计时器。
这样CPU就可以借助页目录和MMU将线性地址转换为物理地址了。

由于频繁查询页表会影响效率，因此CPU会把已经映射过地址缓存到TLB（translation lookaside buffer），需要映射地址时会先从TLB中查找，
没有的话再去查页表，然后写入TLB。
如果对应物理内存页还没映射，就会发生 page fault。


## 内存分段分页管理
段页机制是操作系统管理内存的一种方式。

- 直接寻址：早期内存较小。通过硬编码，直接定位到内存地址。
    - 可控性弱
    - 难以重定位
    - 难以维护

由此演进

- 分段机制：8086处理器，寻址空间达到了1MB，地址线扩展了20位，为了能在16位的寄存器上寻址20位的地址空间，引入段的概念，即
    内存地址=段基址左移4位+偏移
- 分页机制：随着寻址空间进一步扩大，虚拟内存技术的引入，操作系统引入分页机制。逻辑地址经过段机制转换得到的地址是中间地址，还需要通过页机制转换，
    才能得到实际地址。即 逻辑地址--> 分段机制（线性地址）-->分页机制(物理地址)


## 进程状态
五种状态：新建，就绪，运行，阻塞，死亡。

### 进程各状态间的转换
- 就绪：进程已处于准备好运行的状态，即进程已分配到除CPU以外的所有必要资源。这个必要资源是什么呢？虚拟地址空间？只需要获取CPU便可执行
- 运行：进程获取到CPU，正在运行
- 阻塞：正在执行的进程由于发生某个事件，如i/o请求，或申请缓冲区失败等，暂时无法继续执行的状态。


![Image text](https://raw.githubusercontent.com/jizengguang/PrepareForInterview/master/Picture/process_status.png)


## 进程间通信
主要分为三类
- 共享存储系统类： 像是复制粘贴
- 消息传递系统类： 消息传递机制
- 管道通信系统类： 
    - 管道：单向，先进先出，无结构，固定大小的字节流。
    - 信号量：一个计数器，用来控制多个进程对共享资源的访问。
    - 消息队列：系统内核保存消息的队列，在内核中以链表的形式出现。
    - 共享内存：共享内存允许两个或多个进程访问同一个逻辑内存。
               这一段内存可以被两个或两个以上的进程映射至自身的地址空间中。是进程间通信方式最高的效率的一种。
    - 套接字：主要用于不同机器间的进程通信。


## 进程同步
进程同步的主要任务：是对多个相关进程在执行次序上进行协调，以使并发执行的各个进程能够有效的共享资源和相互合作，从而使程序的执行具有可再现性。

同步机制遵循的原则：
- 空闲让进
- 忙则等待（保证对临界区的互斥访问）
- 有限等待（有限代表有限的时间，防止死锁）
- 让权等待（当进程不能进入自己的临界区时，应释放处理机，以免陷入忙等状态）


## 进程的调度
**调度种类**
- 高级调度：又称作业调度，它决定把后备作业调入内存运行。
- 低级调度：又称进程调度，它决定就绪队列中的某个进程获得CPU
- 中级调度：在虚拟存储器中引入，在内、外存对换区进行进程对换。

**非抢占式调度与抢占式调度**
- 非抢占式：分派程序一旦把处理机分配给某个进程便让它一直运行下去，直到进程完成或发生进程调度。进程调度是因某事件导致阻塞时，才将处理机分配给其他进程。
- 抢占式：操作系统会将在运行的进程强制暂停，由调度程序将CPU分配给其他就绪进程的调度方式。

## 调度算法
**FIFO 先来先服务FCFS**
- 调度的顺序就是任务到达就绪队列的顺序
- 公平、简单(FIFO队列)、非抢占、不适合交互式
- 未考虑任务特性，平均等待时间可以缩短

**最短作业优先**
- 最短的作业(CPU区间长度最小)最先调度
- SJF可以保证最小的平均等待时间

**优先权调度**
- 每个任务关联的一个优先权，调度优先权最高的任务
- 注意：优先权最低的任务一直就绪，得不到运行，出现"饥饿"现象

**时间片轮转调度算法**
- 按时间片轮转调度
- 优点: 定时有响应，等待时间较短；缺点: 上下文切换次数较多
- 时间片太大，响应时间太长；吞吐量变小，周转时间变长；当时间片过长时，退化为FCFS

**多级队列调度**
- 按照一定规则建立多个进程队列
- 不同的队列有固定的优先级
- 不同的队列可以给不同的时间片和采用不同的调度方法
- 存在问题1：没法区分I/O bound和CPU bound
- 存在问题2：也存在一定程度的“饥饿”现象


**多级反馈调度**
- 在多级队列的基础上，任务可以在队列之间移动，更细致的区分任务
- 可以根据“享用”CPU时间多少来移动队列，阻止“饥饿”
- 最通用的调度算法，多数OS都使用该方法或其变形，如UNIX、Windows等


# io多路复用
## 定义
IO多路复用是一种同步IO模型，实现一个线程监控多个文件句柄。一旦某个文件句柄就绪，就能通知应用程序进行相应读写操作，没有文件句柄就绪时会阻塞应用程序，
交出CPU。多路指的是网络连接，复用指的是同一个线程。

io多路复用指的是，单个线程通过记录跟踪每个sock的状态来同时管理多个i/o流。
发明这个的原因是，尽量多的提高服务器端的吞吐能力。

## 为什么会有IO多路复用
- BIO 同步阻塞
服务器采用单线程，当accept接收一个请求后，在recv或send调用阻塞时，无法接收其他请求。
服务器采用多线程，当accept接收一个请求后，开启线程进行recv,可以完成并发处理。但随着请求数增加，大量线程占用很大内存空间，线程切换也带来很大开销。

- NIO 同步非阻塞
服务器当accept一个请求后，加入到一个fds集合，每次轮询fds集合recv数据，没有数据立即返回错误。 每次轮询所有会很浪费CPU。

- IO多路复用
服务器端采用单线程通过select/poll/epoll等系统调用获取fd列表，遍历有时间fd进行accept/recv/send使其能支持更多并发连接请求。


## select/poll/epoll 原理及底层实现

### select
可以设置要监听的描述符，也可以设置等待超时时间。如果有事件就绪或超时，select函数就会返回，支持监听可读，可写，异常三类事件。
```go
    int main() {
      /*
       * 这里进行一些初始化的设置，
       * 包括socket建立，地址的设置等,
       */
    
      fd_set read_fs, write_fs;
      struct timeval timeout;
      int max = 0;  // 用于记录最大的fd，在轮询中时刻更新即可
    
      // 初始化比特位
      FD_ZERO(&read_fs);
      FD_ZERO(&write_fs);
    
      int nfds = 0; // 记录就绪的事件，可以减少遍历的次数
      while (1) {
        // 阻塞获取
        // 每次需要把fd从用户态拷贝到内核态
        nfds = select(max + 1, &read_fd, &write_fd, NULL, &timeout);
        // 每次需要遍历所有fd，判断有无读写事件发生
        for (int i = 0; i <= max && nfds; ++i) {
          if (i == listenfd) {
             --nfds;
        // 这里处理accept事件
                 FD_SET(i, &read_fd);//将客户端socket加入到集合中
              }
              if (FD_ISSET(i, &read_fd)) {
                --nfds;
                // 这里处理read事件
              }
              if (FD_ISSET(i, &write_fd)) {
                 --nfds;
                // 这里处理write事件
              }
            }
          }
        
```
fd_set 是无符号long型数组，共16个元素，每一位对应一个fd，最多可以监听1024个。
每次调用select都要传递所有监听集合，就需要频繁的从用户态到内核态拷贝数据。
即便有fd就绪了，也需要遍历整个监听集合，来判断哪个fd是可操作的。

#### select缺点
- 单个进程打开的fd是有限的，最多1024个
- 每次调用select，都需要把fd集合从用户态拷贝到内核态，开销很大。
- 对socket扫描是线性扫描，轮询方式，高并发时效率较低


### poll 
支持的最多监听数目等于最多打开的文件描述符个数。
也需要传递所有监听集合
需要遍历整个监听集合来判断哪个fd是可操作的。

与select相比，只是少了fd 1024限制

#### poll缺点
同select缺点 2，3


### epoll
```go
    #include <sys/epoll.h>
    
    // 数据结构
    // 每一个epoll对象都有一个独立的eventpoll结构体
    // 用于存放通过epoll_ctl方法向epoll对象中添加进来的事件
    // epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可
    struct eventpoll {
        /*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/
        struct rb_root  rbr;
        /*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/
        struct list_head rdlist;
    };
    
    // API
    
    int epoll_create(int size); // 内核中间加一个 ep 对象，把所有需要监听的 socket 都放到 ep 对象中
    int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); // epoll_ctl 负责把 socket 增加、删除到内核红黑树
    int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);// epoll_wait 负责检测可读队列，没有可读 socket 则阻塞进程
```
epoll提供三个接口:
epoll_create用于创建一个epoll，并获取一个句柄。
epoll_ctl用于添加或删除fd对应的事件信息。
除了指定fd和要监听的事件类型，还可以传入一个event_data，通常会按需定义一个数据结构，用于处理对应的fd。每次都只需要传入一个要操作的fd，
无需传入所有监听集合，而且只需要注册这一次。
通过 epoll_wait得到的fd集合都是已经就绪的，逐个处理即可，无需遍历所有监听集合。

#### epoll缺点
只能工作在Linux下

### epoll水平触发LT与边缘触发ET模式的区别
- LT模式下，只要这个fd还有数据可读，每次epoll_wait都会返回它的事件，提醒用户程序去操作。
- ET模式下，它只会提醒一次，直到下次再有数据流入之前都不会再有提示了，无论fd中是否还有数据可读。所以在ET模式下，read一个fd时一定要把buffer读完。


## select/poll/epoll区别
数据结构： bitmap, 数组， 红黑树
支持的最大连接数：1024， 无上限，无上限
工作效率：轮询O（N），轮询O（N），回调O（1）
fd拷贝： 每次调用select拷贝，每次调用poll拷贝，fd首次调用epoll_ctl拷贝 每次调用epoll_wait不拷贝。


# Linux下硬链接和软链接的区别
Linux下文件是通过索引节点来识别文件的。

## 硬链接
ln默认创建的是硬链接。
多个文件名指向同一个索引节点是存在的。所以，硬链接是指通过索引节点来进行的连接。
即，每个硬链接都是一个指向对应区域的文件。
硬链接的作用是，允许一个文件拥有多个有效路径名。
只删除一个连接不会影响索引节点本身和其他连接，只有最后一个被删除，索引节点才会被删除。

## 软链接
软链接又叫符号链接，即一个文件包含了另一个文件的路径名。
软链接可以是任意文件或目录。有点像Windows的快捷方式，删除链接文件时，只是删除链接文件，不会删除源文件本身。

## 区别
|属性|软链接|硬链接|
|:---:|:---:|:---:|
|lnode|源文件和链接文件拥有不同的lnode,表明他们是不同的文件|共用一个lnode，就像一个文件有多个文件名，他们是同一个文件|
|文件属性|链接文件|与源文件平等|
|跨越文件系统建立|可以|不可以|
|链接数目|链接数目不会增加，文件大小不一样|数目和大小和源文件一样|

# 死锁
A进程占着a锁，想要获得b锁，在同时，B进程占着b锁，想要获取a锁。形成死锁。

## 死锁的四个条件
- 互斥：一段时间内，某资源只由一个进程占用，其他想使用的只能排队等。
- 请求和保持： 进程至少已经保持了一个资源。至少已经占着盆里的了，还想拿锅里的。而锅里的被别人占着，自己又不放手盆里的。
- 不剥夺：进程已获得的资源，不使用完不能强抢，只能等它自己释放。
- 环路等待：我在等你释放，你在等我释放。形成资源的环路。

## 解决死锁
破坏4个条件中的任意一个即可。


# 并发、并行
- 并发：两个队列一台咖啡机是并发；两个或多个事件在同一事件间隔内发生
- 并行：两个队列两台咖啡机是并行；两个或多个事件在同一时刻发生。


# 孤儿进程、僵尸进程
- 没有父进程的进程就是孤儿进程，孤儿进程会被init领养，成为一个准守护进程。
- 如果父进程还活着，但不给子进程（wait,waitpid）,子进程就是僵尸进程。

守护进程是一类脱离终端在后台执行的程序。通常以d结尾，随系统启动，其父进程通常是init进程。

当子进程退出时, 父进程需要wait/waitpid系统调用来读取子进程的exit status, 然后子进程被系统回收。
如果父进程没有wait的话, 子进程将变成一个"僵尸进程", 内核会释放这个子进程所有的资源，包括打开的文件占用的内存等。
但在进程表中仍然有一个PCB, 记录进程号和退出状态等信息, 并导致进程号一直被占用, 而系统能使用的进程号数量是有限的(可以用ulimit查看相关限制),
 如果产生大量僵尸进程的话, 将因为没有可用的进程号而导致系统不能产生新的进程。




# 扫描二维码原理

# Linux命令 
## 修改文件名
mv A B 把A改成B

## 修改一组文件名
rename 's/new/old/' *.new
带.new后缀的文件都被改成 某某.old

## 查看文件内容
cat A 或者vim 打开

## 查找文件
whereis A 查找A文件路径

## 查看暴露端口号
netstat 网络连接、路由表、接口统计信息、伪装连接以及多播成员。
lsof 能够列出打开的文件，并列出系统上被进程打开的文件的相关信息。



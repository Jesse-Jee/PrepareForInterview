#分页分段内存管理


#  进程五种状态及状态间转移


## 进程 & 线程
###   进程  
进程是操作系统资源分配的基本单位。
一个程序在系统上运行时，就是一个进程。
每个进程都有自己的虚拟地址空间，虚拟地址空间划分为内核空间和用户空间。操作系统运行在内核空间，内核空间由所有进程的地址空间共享。
用户程序不能直接访问内核空间，操作系统保存的进程控制信息在内核空间中。  
进程控制信息PCB中包含：  
- 页目录  
- 父进程ID
- 状态
- 句柄表
- 等等

###   线程  
线程是进程中的执行体，它会有指定的执行入口，通常是某个函数的指令入口。线程执行时要使用从进程虚拟空间中分配的栈空间来存储数据。
被称为线程栈。在创建线程时，操作系统会使用用户空间和内核空间分别分配两段栈，就是通常所说的用户栈和内核栈。线程切换到内核态时会使用内存栈。
是为了不允许用户代码对其进行修改以保证安全。操作系统也会保存每个线程控制信息。
线程控制信息TCB包括：
- 执行入口
- 线程栈
- 线程ID 
- 等等


在PCB中有进程拥有的线程列表。同一个进程中的线程，会共享进程的地址空间和句柄表等资源。
在linux中，使用的是task_struct结构体保存进程和线程控制信息。进程在创建子进程时，会指定它和自己使用同一套地址空间和句柄表等资源。
用这种方法来实现多线程的效果。


###  为什么说线程是操作系统调度与执行的基本单位。  
如果CPU要执行进程中的线程，CPU的指令指针会指向线程的执行入口。当前执行用户空间的程序指令，栈基ebp和栈指针寄存器esp会记录用户栈的位置。
CPU面向的是某个线程，所以才说，线程是操作系统调度与执行的基本单位。


###  进程与线程的关系  
一个进程中至少有一个线程，这个线程叫做主线程，可以认为它是进程中的第一个线程，一般是由父进程或操作系统创建的。  
进程中的其他线程，一般都是由主线程创建的。



###  用户态和内核态的转变  
线程中发生函数调用时，会在线程栈中分配函数调用栈，而虚拟内存分配，文件操作，网络读写等功能都是由操作系统来实现的，再向用户暴露接口。
所以线程免不了调用操作系统提供的系统服务。CPU中有特权级的标识，用于记录当前程序执行在用户态还是内核态，只有标识为内核态是，才能访问内核空间。
当系统调用发生时，线程会使用内核栈，执行内核空间的系统函数。这被称为从用户态切换到内核态。
最初，系统调用是通过软中断来实现的，所谓软中断，就是通过指令来模拟中断。
还有一个是硬中断，CPU会在内存中存一张中断向量表，用来把这个中断编号映射到相应的处理程序。例如Linux系统中，系统调用中断对应的编号为0X80，
对应的处理程序就是用来派发系统调用的。系统调用太多，不能每个都分配一个编号，于是操作系统又实现了一张系统调用表，用于通过系统调用编号找到对应
系统函数入口。

用户程序会把要调用的系统函数编号存入特定寄存器，通过寄存器或用户栈来传递其他所需参数，然后用 int 0x80来触发系统调用中断。
在硬件层面上，CPU有一个中断控制器，负责接收中断信号，切换到内核态，保存用户态执行现场。
后来，改为使用特殊指令触发系统调用，例如，syscall，当CPU执行到这些指令时，就会陷入内核态，从专用寄存器中拿到派发入口地址。
省去了查询中断向量表的过程。等系统调用完成后，再利用之前保存的信息，恢复线程在用户态的执行现场。


###   线程切换和进程切换
1. 同进程的线程a1 切换到线程a2，只涉及线程切换，只需要将a1的执行现场保存下来，再把指令指针，栈指针等寄存器的值修改为线程a2，
修改内存中调度相关的数据结构，就完成了同进程间的线程切换。等到a1时间片恢复后，根据之前保存的执行现场，恢复即可。
2. 从进程A的线程a1切换到进程B的线程b1，将CPU保存的页目录地址换为B的。

进程空间切换和线程空间切换的区别就是，进程间切换会导致地址空间等进程资源发生变化，会导致TLB缓存失效，代价更大。


###   什么是虚拟内存
DOS时期，进程使用内存是直接使用物理地址，因为进程会修改地址上的信息，不同进程可能造成内存修改冲突。
甚至可能会覆盖操作系统使用的内存，后来，出现了保护模式，内存使用虚拟内存而非物理内存。操作系统负责把虚拟内存映射到物理内存上。

如何映射？
保护模式提供物理内存分页，把物理内存中的每4KB作为一页。从虚拟内存到物理内存以页为单位映射。
操作系统会以链表的形式记录各个进程的控制信息，在window中叫内存控制块，Linux中叫task_struct。每个进程的控制信息中都有一个这样的指针，
记录当前进程"页目录"的物理地址。页目录也是一个内存页，存储的是一系列指针，指向同样用来存储物理内存页起始地址的"页表"。

在32位CPU下，一个地址占4个字节，一个页目录就可以寻址1024个页表，而每个页表又可以寻址1024个物理内存页，每个页4K。
因此， 1024 * 1024 * 4K = 4GB

线性地址：
前10位从页目录中选择一个页表。
中10位从页表中锁定一个物理内存页。
后12位存储一个相对内存页起始地址的偏移量。
这样就实现了一个虚拟内存到一个物理内存的映射。

这样就可以让不同进程使用不同的物理地址，也可以让两个进程使用同一块物理地址实现共享内存。


页表中的记录：
内存页大小都是4KB，所以内存页的地址一定是4K的整数倍，也就是说，它的低12位一定是0。因此页表中的每一条记录都有一个12位的空闲空间可以使用。
它们可以用来标识对应物理内存页是否可读可写可执行等信息，其中一位用于标识物理内存页是否已经映射。

###  进程向操作系统申请映射的内存   
通常不会一申请就立马分配。
进程拿到的是线性地址，CPU拿到的自然也是线性地址，线性地址的转换会交由CPU中MMU模块完成。当前进程持有的页目录的物理地址会被保存到特定计时器。
这样CPU就可以借助页目录和MMU将线性地址转换为物理地址了。

由于频繁查询页表会影响效率，因此CPU会把已经映射过地址缓存到TLB（translation lookaside buffer），需要映射地址时会先从TLB中查找，
没有的话再去查页表，然后写入TLB。
如果对应物理内存页还没映射，就会发生 page fault。





## 进程状态
五种状态：新建，就绪，运行，阻塞，死亡。



#进程间通信


#select/poll/epoll 原理及底层实现


#io多路复用


#硬链接和软链接


#内存分页


#死锁


#并发、并行

#ping命令的底层原理

#共享内存


#孤儿进程


#扫描二维码原理

#Linux命令 给文件改名 查文件 查文件内容 查暴露端口

#Linux grep命令



# Redis支持的数据类型及底层原理
- string
    - SDS 简单动态字符串
- list
    - 双向链表
    - zipList压缩列表
- hash
    - 哈希表
    - 压缩列表
- set
    - 哈希表
    - 整数数组
- sorted set（zset）
    - 压缩列表
    - 跳表
    
拓展的话，还有：
- bitmap 用于二值统计，非0即1的场景，如签到
- Hyperloglog 用于统计基数
- GEO 基于位置信息服务的应用，附近的餐馆等。

## string
### 使用
set key value  
get key  
mset key1 value1 key2 value2  
mget key1 key2  
INCR key 递增数字  
INCRBY key increment 递增指定数字  
DECR key 递减数字   
DECRBY key increment 递减指定数字  
strlen key 获取字符串长度

### 分布式锁
setnx key value   
set key value [EX seconds][PX milliseconds][NX|XX]  
**EX**:key 存在多少秒后过期     
**PX**：key在多少毫秒后过期
**NX**：当key不存在是才能创建key 效果等同于setnx
**XX**：当key存在是覆盖key

### 应用场景
- 商品编号、订单号采用INCR生成
- 点赞数之类的

## hash
### 使用
Hset key filed value  
hget key filed  
hmset key filed1 value1 filed2 value2  
hmget key filed1[filed...]  
hgetall key  
hlen  
hdel  

### 应用场景
购物车

## list
### 使用
LPUSH key value
RPUSH key value
LRANGE key start stop
LLEN key

### 应用场景
微信文章订阅公众号：公众号发布的新文章，将其ID放到我这个关注者的list中来。

## set
### 使用
SADD key member  
SREM key member  删除
SMEMBERS key  获取集合中所有元素  
SISMEMBERS key member  判断元素是否在集合中     
SCARD key  集合中元素个数  
SRANDMEMBER key [数字] 从集合中随机弹出一个元素，不删除    
SPOP key 从集合中随机弹出一个元素，删除。  

### 集合运算
- 差集 SDIFF key
- 交集 SINTER key
- 并集 SUNION key  


### 应用场景
- 微信抽奖小程序 SRANDMEMBER 如果不重复获奖，用SPOP
- 朋友圈点赞 
- 微博好友关注，共同关注的人，我关注的人也关注了他
- 推可能认识的人

## zset
### 使用
ZADD key score member  
ZRANGE key start stop 从小到大排序  
ZSCORE key member  获取元素分数  
ZREM key member  删除元素  
ZRANGEBYSCORE key min max 获取指定范围元素    
ZINCRBY key increment member 增加某个元素分数  
ZCARD key  获取集合中元素数量  
ZCOUNT key min max指定分数范围内的元素个数  

### 应用场景
- 热销
- 打赏排行  



# Redis内存淘汰策略
执行内存淘汰策略前，要先经过删除策略。

## Redis过期键删除策略
- 定时删除：立即删除能保证内存新鲜度，因为它能在键一过期立马删除，占用的内存也会随之释放。
    - 但是，对CPU不友好，因为删除会占CPU时间。实时删除，会让CPU性能损耗，影响数据的读取操作。
- 惰性删除：数据到达过期时间，不处理。等下次访问该数据时，如果没过期，返回数据，如果过期了，删除。
    - 但是，对内存不友好。万一这个数据后面不被访问了呢？一直占用着内存。
- 定期删除：每隔一段时间执行一次删除过期键的策略。并通过限制删除操作执行的时长和频率来减少删除操作对CPU的影响。
    - 周期性轮询时效性数据，采用随机抽取策略，利用过期数据占比的方式控制删除额度。
        - 检测频度可自定义设置
        - 长期占用内存的冷数据会被清除。
    - 难点：确定删除操作执行的时长和频率。太频繁的话CPU一样要崩溃。执行不频繁的话，和惰性一样，还是会导致数据不能及时删掉。
    
**上述三种都有漏洞，必须有兜底的策略。**     


## 8种缓存淘汰策略
在redis.conf中设置的。
默认为不驱逐

- 不驱逐：默认，存满返回错误。我存满了，不干了。
- allkeys-lru：对所有keys使用lru算法删除
- volatile-lru：对所有设置了过期时间的key使用LRU算法删除。
- allkeys-random：对所有key进行随机删除
- volatile-random：对所有设置了过期时间的key随机删除。
- volatile-TTL：删除马上过期的key
- allkeys-lfu：对所有key使用lfu算法删除。
- volatile-lfu：对所有设置过期时间的key使用lfu算法删除。

LRU：最近最少使用
LFU：最近最少频率使用

## 淘汰策略总结
- 两个维度
    - 过期的中选
    - 所有的里面选
- 四个方面
    - LRU
    - LFU
    - random
    - TTL
    
## 你平时用哪一种
allkeys-lru

### 如何配置，如何修改？
- redis.conf文件中设置 maxmemory-policy allkeys-lru
- config set maxmemory-policy allkeys-lru

# zset时间复杂度
zset的底层是什么实现的？
压缩列表和跳表。
跳表是什么呢？
链表加多级索引，就是跳表。
跳表的查询，时间复杂度是O(logN)
插入和删除，时间复杂度也为O(logN)


# 缓存和数据库间的一致性问题

## 缓存的类型
- 只读缓存：
    - 应用要读取数据时，调用Redis get接口。  
    - 应用要写数据时，会直接发往数据库，在数据库中增删改。  
    - 对于要删改的数据，如果Redis已经缓存，需要先把缓存删除，Redis中就没有这些数据了。  
    当下次查询时，发生缓存缺失，应用会把数据从数据库读取出来，写入到缓存中。  
    - 数据不会有丢失风险
    
- 读写缓存：
    - 在缓存中直接对数据进行增删改
    - 最新数据在Redis中，万一宕机，会发生数据丢失。
    - 策略：
        - 同步直写：缓存写完了，也要等数据库写完才返回，增加响应延迟。
        - 异步写回：写操作先在缓存处理，等到要被从内存中淘汰出来的时候，缓存将他们写回后端数据库。万一掉电，会丢失。

## 什么是一致性？
- 缓存中有数据，必须与数据库中值一致
- 缓存中无数据，数据库中必须是最新值

## 数据不一致是如何发生的？
- 读写缓存下：
    - 同步写回策略：在业务应用中使用事务，保证数据库更新和缓存更新的原子性，要么同成功，要么同失败。
    - 异步写回策略：如果对数据一致性要求不高，如电商产品非关键属性。
- 只读缓存下：
    - 新增、删除、修改都直接操作数据库，如果缓存中有，先删除缓存。下次查询时，发生缓存缺失，再更新到Redis缓存中。

不符合一致性的，就是数据不一致了。
只读模式下删改数据时：
    应用既要更新数据库，又要删除缓存数据。这两个操作如果无法保证原子性，就会出现数据不一致。
    - 先删缓存，再改数据库的情况。如果缓存删除成功，数据更新失败，那么应用访问数据时，缓存中没有数据，发送缓存缺失，从数据库中获取的还是旧值。
    - 先改数据库，再删缓存。如果改数据库成功了，删缓存失败了。数据又不一致。  

## 如何保证数据一致性
   重试机制  
    把要删除或更新的数据，暂存在消息队列，当应用没能成功删除或更新时，可以从消息队列中重新拿到这些值，然后再次删除或更新。超过一定的重试次数就报错。
    假设在大量并发请求的情况下，还是有可能发生不一致的问题。  
    如：  
   - 情况一、先删缓存，再更新数据库  
    线程A删除缓存后，还没来得及更新数据库，线程B就来读取缓存，发生缓存缺失，就会去数据库读。这时带来两个问题。
        - 线程B读取到数据库旧值
        - 线程B从数据库读取到旧值后，把旧值写入缓存，其他线程会从缓存读取到旧值。
    等线程A再写入到数据库中后，出现了缓存与数据库值不一致情况。  
        - **解决**（延迟双删策略）
         线程A更新完数据库后，先sleep一会，再执行一遍缓存删除操作。sleep时间统计下实际线程读数据和写缓存的时间作为基础。
         
   - 情况二、先更新数据库值，再删除缓存值
    线程A删除了数据库中的值，还没来得及删缓存中的，线程B从缓存中读取数据。
    这种情况如果并发请求不是很多，一般缓存删除是很快的。这种情况对业务影响较小。     
![Image_text](https://raw.githubusercontent.com/jizengguang/PrepareForInterview/master/Picture/redis_data_con.png)

**优先使用先更新数据库，再删除缓存的方式**
- 先删缓存，再更新数据库的话，有可能导致请求因访问缺失而访问数据库，增加数据库压力。
- 延迟双删策略的sleep时间不好确定。

# 缓存雪崩，缓存穿透，缓存击穿
## 缓存雪崩
**大量应用请求无法在Redis缓存中进行处理，紧接着大量请求发送到数据库，导致数据库压力剧增。**
- 缓存中有大量数据同时过期，导致大量请求无法得到处理。  
    当数据保存在缓存中，并且设置了过期时间时，如果在某一个时刻，大量数据同时过期，此时，应用再访问这些数据的话，就会发生缓存缺失。
    紧接着，应用就会把请求发送给数据库，从数据库中读取数据。如果应用的并发请求量很大，那么数据库的压力也就很大，
    这会进一步影响到数据库的其他正常业务请求处理。
    - 避免设置相同的过期时间，设置过期时间时，加个较小的随机数。
    - 服务降级：针对不同的数据采取不同的处理方式。
        - 当业务查询的是非核心数据，暂时停止从缓存中查询这些数据，直接返回预定义的或者空值。
        - 如果查询的是核心数据，可以继续查询。
- Redis实例宕机
    - 业务系统实现熔断或限流
      - 熔断
      就是业务应用调用缓存接口时，缓存客户端并不把请求发给 Redis 缓存实例，而是直接返回，
      等到 Redis 缓存实例重新恢复服务后，再允许应用请求发送到缓存系统。  
      通过监控检测Redis宕机后，启动服务熔断机制。这种对业务影响较大
      - 限流
      请求入口前端控制每秒进入系统的请求数。
   - 事前预防
## 缓存击穿
**针对某个访问非常频繁的热点数据请求，无法在缓存中进行处理，紧接着，访问该数据的大量请求，一下子发送到了数据库。数据库压力剧增**    
一般发生在热点数据过期失效时。  
解决办法：访问频繁的热点数据，不设置过期时间。

## 缓存穿透
**要访问的数据既不在Redis缓存中，也不在数据库中。**
这就导致请求访问Redis时发现缓存缺失，再去访问数据库，发现也没有要访问的数据。应用就无法从数据库中读取数据再写入缓存。如果应用有大量并发读请求，
就会给缓存和数据库增加大量压力。    
**发生场景：**  
- 业务层误操作，把缓存和数据库中数据误删。
- 恶意攻击，专门访问数据库中没有的数据。   
 
**应对方案：**  
 - 缓存空值或缺省值
 - 使用布隆过滤器先判断，布隆过滤器可以使用Redis实现。
 - 前端进行请求合法性检测

以上雪崩，击穿，穿透。最好是采取预防性措施：
- 针对缓存雪崩，合理地设置数据过期时间，以及搭建高可靠缓存集群；
- 针对缓存击穿，在缓存访问非常频繁的热点数据时，不要设置过期时间；
- 针对缓存穿透，提前在入口前端实现恶意请求检测，或者规范数据库的数据删除操作，避免误删除。  


# Redis线程模型
## Redis为什么快？
- 内存，采用了高效的数据结构
- 多路复用机制，

6.0之前的版本都是单线程异步处理IO
这里的单线程，主要指的是网络IO和键值读写是由一个线程完成的。但其他功能如持久化，异步删除，集群数据同步等，都是额外线程做的。
Redis处理请求要经过几步：
1. 接收：通过TCP接收到命令，可能经过多次TCP，ACK，IO操作
2. 解析：将命令取出来
3. 执行：到对应地方把value读出来
4. 返回：把value通过TCP返回给客户端。

网络IO处理：
- bind()
- listen()
- accept()
- recv()
- parse()

键值读写：
- get  

网络IO回复：
- send()


可能会阻塞在 accept()
但是socket模型支持非阻塞模式。  

**基于多路复用的高性能IO模型**
一个线程处理多个IO流，select/epoll机制。
该机制允许内核中，同时存在多个监听套接字和已连接套接字。
select/epoll 提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数。  
select/epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件。这些事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理。

单线程模型的瓶颈
- 大value拉胯
- QOS无法更上一层楼

Redis主线程的时间消耗主要是：
- 逻辑计算
- 同步IO读写，拷贝数据导致的消耗

当value比较大时，瓶颈首先会出现在同步IO上，主要消耗在：
- 从socket中读取请求数据，会从内核态将数据拷贝到用户态（read调用）
- 将数据回写到socket，会将数据从用户态拷贝到内核态（write调用）

这部分读写占用了CPU大量时间，这也是Redis引入多线程IO的目的。


**多线程IO：**
- 用一组单独的线程专门进行 read/write socket读写调用 （同步IO）
- 读回调函数中不再读数据，而是将对应的连接追加到可读clients_pending_read的链表
- 主线程在beforeSleep中将IO读任务分给IO线程组
- 主线程自己也处理一个IO读任务，并自旋式等IO线程组处理完，再继续往下
- 主线程在beforeSleep中将IO写任务分给IO线程组
- 主线程自己也处理一个IO写任务，并自旋式等IO线程组处理完，再继续往下
- IO线程组要么同时在读，要么同时在写
- 命令的执行由主线程串行执行(保持单线程)
- IO线程数量可配置


# 如何提高缓存命中
## 什么叫缓存命中
Redis中有相应的数据，就直接读取Redis，性能非常快。


# 持久化比较
## RDB
## AOF
### AOF重写机制


# hash扩容

# rehash